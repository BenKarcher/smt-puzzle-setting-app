/**
 * Compiles puzzle configuration (grid + variables + rules + clues) into MiniZinc model
 */

export class MiniZincCompiler {
  constructor() {
    this.reset();
  }

  reset() {
    this.grid = null;
    this.variables = [];
    this.globalRules = [];
    this.localRules = [];
    this.clues = [];
  }

  /**
   * Set grid configuration
   * @param {object} gridConfig - { type: 'rectangular', rows, cols } or { type: 'preset', preset: 'sudoku' }
   */
  setGrid(gridConfig) {
    this.grid = gridConfig;
    return this;
  }

  /**
   * Add variable types to the puzzle
   * @param {Array<string>} variableTypes - e.g., ['numbers-all', 'shading']
   * @param {object} config - Additional config like { numberRange: [1, 9] }
   */
  setVariables(variableTypes, config = {}) {
    this.variables = variableTypes.map(type => ({
      type,
      config: config[type] || {}
    }));
    return this;
  }

  /**
   * Add a global rule
   * @param {object} rule - Rule definition with constraint MiniZinc code
   */
  addGlobalRule(rule) {
    this.globalRules.push(rule);
    return this;
  }

  /**
   * Add a local rule with placement
   * @param {object} rule - Rule definition
   * @param {object} placement - { cells: [[row, col], ...], data: {...} }
   */
  addLocalRule(rule, placement) {
    this.localRules.push({ rule, placement });
    return this;
  }

  /**
   * Add an instantiable constraint instance
   * @param {object} rule - Rule definition with constraintTemplate or generateConstraint
   * @param {Array} groups - [{cells: [[r,c], ...], value: x}, ...]
   */
  addConstraintInstance(rule, groups) {
    this.localRules.push({ rule, groups });
    return this;
  }

  /**
   * Add a clue (given value)
   * @param {number} row - Row index (0-based)
   * @param {number} col - Column index (0-based)
   * @param {string} variableType - Which variable this clue is for
   * @param {any} value - The clue value
   */
  addClue(row, col, variableType, value) {
    this.clues.push({ row, col, variableType, value });
    return this;
  }

  /**
   * Compile everything into a complete MiniZinc model
   * @returns {string} Complete MiniZinc model code
   */
  compile() {
    if (!this.grid) {
      throw new Error('Grid configuration not set');
    }

    const parts = [];

    // Add header comment
    parts.push('% Auto-generated MiniZinc model for puzzle');
    parts.push('% Generated by SMT Puzzle Setter\n');

    // Add necessary imports
    parts.push('% Import standard library functions');
    parts.push('include "alldifferent.mzn";\n');

    // Add grid dimensions
    const { rows, cols } = this.getGridDimensions();
    parts.push(`int: rows = ${rows};`);
    parts.push(`int: cols = ${cols};`);
    parts.push(`set of int: ROWS = 1..rows;`);
    parts.push(`set of int: COLS = 1..cols;\n`);

    // Add region data if available
    if (this.grid.regions) {
      parts.push('% Region definitions');
      parts.push(`int: num_regions = ${this.grid.regions.length};`);
      parts.push(`set of int: REGIONS = 1..num_regions;`);

      // Create region membership array
      parts.push(`array[ROWS, COLS] of int: region = array2d(ROWS, COLS, [`);
      const regionData = Array(rows).fill(null).map(() => Array(cols).fill(0));

      // Fill region data
      for (let regionIdx = 0; regionIdx < this.grid.regions.length; regionIdx++) {
        for (const [r, c] of this.grid.regions[regionIdx]) {
          regionData[r][c] = regionIdx + 1; // 1-based
        }
      }

      // Output as comma-separated values
      const regionValues = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          regionValues.push(regionData[r][c]);
        }
      }
      parts.push(`  ${regionValues.join(', ')}`);
      parts.push(`]);\n`);
    }

    // Add variable declarations
    parts.push('% Variable declarations');
    for (const varDef of this.variables) {
      parts.push(this.compileVariableDeclaration(varDef, rows, cols));
    }
    parts.push('');

    // Add clue constraints
    if (this.clues.length > 0) {
      parts.push('% Clue constraints');
      for (const clue of this.clues) {
        parts.push(this.compileClue(clue));
      }
      parts.push('');
    }

    // Build combined allConstraints array (global + local) that all constraints will receive
    const allConstraints = [
      // Global constraints (with empty groups arrays)
      ...this.globalRules.map(rule => ({
        ruleId: rule.id,
        groups: []
      })),
      // Local constraints (with their groups)
      ...this.localRules
        .filter(lr => lr.groups)
        .map(lr => ({
          ruleId: lr.rule.id,
          groups: lr.groups
        }))
    ];

    // Convert regions to 2D grid format for constraints that need it
    let regionsGrid = null;
    if (this.grid.regions) {
      regionsGrid = Array(rows).fill(null).map(() => Array(cols).fill(0));
      for (let regionIdx = 0; regionIdx < this.grid.regions.length; regionIdx++) {
        for (const [r, c] of this.grid.regions[regionIdx]) {
          regionsGrid[r][c] = regionIdx + 1; // 1-based
        }
      }
    }

    const gridInfo = {
      rows,
      cols,
      regions: regionsGrid
    };

    // Add global rule constraints
    if (this.globalRules.length > 0) {
      parts.push('% Global rule constraints');

      for (const rule of this.globalRules) {
        parts.push(`% Rule: ${rule.name}`);

        // If the rule has a generateConstraint function, use it
        if (rule.generateConstraint) {
          const generatedCode = rule.generateConstraint([], allConstraints, gridInfo);
          if (generatedCode && generatedCode.trim()) {
            parts.push(generatedCode);
          }
        }
        // Otherwise use the static constraint
        else if (rule.constraint) {
          parts.push(this.interpolateConstraint(rule.constraint, { rows, cols }));
        }

        parts.push('');
      }
    }

    // Add local rule constraints
    if (this.localRules.length > 0) {
      parts.push('% Local rule constraints');

      for (const localRule of this.localRules) {
        // New format: groups array
        if (localRule.groups) {
          parts.push(`% Rule: ${localRule.rule.name}`);
          const constraint = this.compileConstraintInstance(
            localRule.rule,
            localRule.groups,
            allConstraints,
            gridInfo
          );
          parts.push(constraint);
          parts.push('');
        }
        // Old format: placement object (for backwards compatibility)
        else if (localRule.placement) {
          parts.push(`% Rule: ${localRule.rule.name} at cells ${JSON.stringify(localRule.placement.cells)}`);
          parts.push(this.interpolateConstraint(localRule.rule.constraint, {
            rows,
            cols,
            cells: localRule.placement.cells,
            ...localRule.placement.data
          }));
          parts.push('');
        }
      }
    }

    // Add solve goal
    parts.push('solve satisfy;\n');

    // Add output
    parts.push('% Output formatting');
    parts.push(this.compileOutput());

    return parts.join('\n');
  }

  /**
   * Get grid dimensions from config
   */
  getGridDimensions() {
    // Grid config already has rows and cols directly from presets or custom
    if (this.grid.rows && this.grid.cols) {
      return { rows: this.grid.rows, cols: this.grid.cols };
    }

    // Fallback for older format
    if (this.grid.type === 'rectangular') {
      return { rows: this.grid.rows, cols: this.grid.cols };
    } else if (this.grid.type === 'preset') {
      const presets = {
        'sudoku': { rows: 9, cols: 9 },
        'sudoku-6x6': { rows: 6, cols: 6 }
      };
      return presets[this.grid.preset] || { rows: 9, cols: 9 };
    }

    throw new Error('Unknown grid type: ' + JSON.stringify(this.grid));
  }

  /**
   * Compile variable declaration
   */
  compileVariableDeclaration(varDef, rows, cols) {
    const { type, config } = varDef;

    switch (type) {
      case 'numbers-all':
        const min = config.min || 1;
        const max = config.max || 9;
        return `array[ROWS, COLS] of var ${min}..${max}: numbers;`;

      case 'numbers-some':
        const nMin = config.min || 1;
        const nMax = config.max || 9;
        return `array[ROWS, COLS] of var 0..${nMax}: numbers; % 0 = empty`;

      case 'shading':
        return `array[ROWS, COLS] of var bool: shaded;`;

      case 'lines-center':
        // For loop puzzles - track connections between cells
        return `array[ROWS, COLS] of var 0..4: connections; % number of line segments through center`;

      case 'lines-edge':
        // Edge lines - horizontal and vertical
        return [
          `array[1..rows, 1..cols+1] of var bool: vedges; % vertical edges`,
          `array[1..rows+1, 1..cols] of var bool: hedges; % horizontal edges`
        ].join('\n');

      default:
        throw new Error(`Unknown variable type: ${type}`);
    }
  }

  /**
   * Compile clue constraint
   */
  compileClue(clue) {
    const { row, col, variableType, value } = clue;
    const r = row + 1; // Convert to 1-based
    const c = col + 1;

    if (variableType === 'numbers-all' || variableType === 'numbers-some') {
      return `constraint numbers[${r}, ${c}] = ${value};`;
    } else if (variableType === 'shading') {
      return `constraint shaded[${r}, ${c}] = ${value};`;
    }

    return `% Unknown clue type: ${variableType}`;
  }

  /**
   * Interpolate constraint template with values
   */
  interpolateConstraint(constraintTemplate, values) {
    // Simple template replacement: ${varName}
    let result = constraintTemplate;
    for (const [key, value] of Object.entries(values)) {
      const regex = new RegExp(`\\$\\{${key}\\}`, 'g');
      result = result.replace(regex, JSON.stringify(value));
    }
    return result;
  }

  /**
   * Compile output section
   */
  compileOutput() {
    const outputs = [];

    // Output each variable type
    for (const varDef of this.variables) {
      const { type } = varDef;

      if (type === 'numbers-all' || type === 'numbers-some') {
        outputs.push(`"numbers:\\n" ++ show2d(numbers)`);
      } else if (type === 'shading') {
        outputs.push(`"shading:\\n" ++ show2d(shaded)`);
      }
    }

    if (outputs.length === 0) {
      outputs.push(`"solved"`);
    }

    // Join outputs with proper MiniZinc syntax
    return `output [${outputs.join(' ++ "\\n\\n" ++ ')}];`;
  }

  /**
   * Compile a constraint instance with template substitution
   * @param {object} rule - Rule with constraintTemplate or generateConstraint function
   * @param {Array} groups - [{cells: [[r,c], ...], value: x}, ...]
   * @returns {string} MiniZinc constraint code
   */
  compileConstraintInstance(rule, groups, allConstraints, gridInfo) {
    const parts = [];

    // Step 1: Process template from constraint.mzn file (if exists)
    if (rule.constraintTemplate) {
      let templateCode = rule.constraintTemplate;

      groups.forEach((group, idx) => {
        const groupNum = idx + 1;

        // Convert 0-based to 1-based indices
        const rows = group.cells.map(([r, c]) => r + 1);
        const cols = group.cells.map(([r, c]) => c + 1);
        const numCells = group.cells.length;

        // Substitutions:
        // $rows1 → [1, 2, 3]
        // $cols1 → [4, 5, 6]
        // $value1 → 15
        // $num_cells1 → 3

        templateCode = templateCode.replace(new RegExp(`\\$rows${groupNum}`, 'g'), `[${rows.join(', ')}]`);
        templateCode = templateCode.replace(new RegExp(`\\$cols${groupNum}`, 'g'), `[${cols.join(', ')}]`);
        templateCode = templateCode.replace(new RegExp(`\\$num_cells${groupNum}`, 'g'), numCells.toString());

        if (group.value !== undefined) {
          templateCode = templateCode.replace(new RegExp(`\\$value${groupNum}`, 'g'), group.value.toString());
        }
      });

      parts.push(templateCode);
    }

    // Step 2: Run JS code generator (if exists)
    // This is called AFTER the template, so it can reference template variables
    if (rule.generateConstraint) {
      const generatedCode = rule.generateConstraint(groups, allConstraints, gridInfo);
      if (generatedCode && generatedCode.trim()) {
        parts.push(generatedCode);
      }
    }

    return parts.join('\n');
  }
}

export default MiniZincCompiler;
